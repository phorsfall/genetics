* Create a ranked selection modules that takes into account population size. (Unlike SegaranRankSelection.)
* Threading for VersusTournament.
* Parameterize elitism in the replacement module.
* Parameterize group size in the versus module.
* Rename Tree#fight to Tree#vs. (Reflects naming of VersusTournament modules.)
* Switch to higher fitness == better. Minimizing problems can use -ve fitness.
* Tree#fight should return the number of points for each player.
* We only need to check if klass responds to :ideal? once. If it does't, we can save calling Population#fittest each generation.

Ideas/Thoughts

* Should we try and mutate and cross? Or just do one?
* Cross-over should return 2 children after doing a subtree swap.
* Mutate could happen in place?
* Graphs. e.g. Generations against fitness. Family tree?
* Parallelism. Tournament selection may be well suited.
* Could implement & (to_proc). Why? If a tree was just a Ruby proc maybe we could do things like: plot(:x => 0..100, :y => 0..100, :function => &tree). Or maybe just implementing call (as an alias of evaluate) would be be good enough.

Longer Term

* Need to either remove default functions from Tree, or allow a way to remove if no required in sub-classes.
* Can the block passed to Population#evolve work as an around filter? e.g.

population.evolve do
  puts Benchmark.realtime do
    yield
  end
end

Maybe we could check the block's arity to decide whether or not this is an around block?